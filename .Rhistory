#df_mod contains observations where group membership does not change on a single day
#so now, let's calculate the unique groups labels, which is the unique combination
#of uniq_id and tank id
df_mod$groupID = paste0("group", df_mod$tank, " ", df_mod$uniq_ids)
#so, to eliminate these observations, use anti-join
#removes observations from df which are present in tanksdays...
df_mod = tanksdays_changingstriders %>% filter(n > 1) %>%
select(-n) %>% #this line removes the n column, which we no longer need
anti_join(df, ., by = c("date", "tank"))
#df_mod contains observations where group membership does not change on a single day
#so now, let's calculate the unique groups labels, which is the unique combination
#of uniq_id and tank id
df_mod$groupID = paste0("group", df_mod$tank, " ", df_mod$uniq_ids)
View(df_mod)
?arrange
#those groups
#to do this, I will group by our new "groupID" variable, and then sort the data
#within that grouping variable by "date", 'time', and 'id' so that when we add
#a new trial column according to date, we can be sure that the earliest date corresponds
#to the earliest trial
#this probably isn't necessary, assuming the data are already correctly sorted, but on the
#off chance that for some data the values are not entered chronologically, this code
#will prevent that from being an issue
#note that in the arrange code, the .by_group argument ensures that the data are arranged
#within their grouping category (rather than as a whole, regardless of grouping)
df_mod = df_mod %>% group_by(groupID) %>% arrange(date, time, id, .by_group = T) %>%
mutate(trial = as.integer(as.factor(date))) %>% ungroup()
#we have found that sex and treatment are problematic because there are multiple
#entries of sex and treatment for some groupID-trial-id combinations
test = df_mod %>% group_by(groupID, trial, id) %>%
summarize( n_treatment = length(unique(Treatment)),
n_sex = length(unique(sex))) %>% ungroup()
View(test)
bloop = df_mod %>% group_by(groupID, trial, id) %>%
summarize(prop_active = sum(activity, na.rm = T)/sum(!is.na(activity)),
prop_mating = sum(mating, na.rm = T)/sum(!is.na(mating)),
sex = unique(sex),
date = unique(date),
Treatment = unique(Treatment),
tank = unique(tank)) %>% ungroup()
#and so now we want to calculate the proportion of time active and mating, within a day,
#for each male, for each of its observed trials, for each of its observed groups
#but remember that trial is the same thing as day
bloop = df_mod %>% group_by(groupID, trial, id) %>%
summarize(prop_active = sum(activity, na.rm = T)/sum(!is.na(activity)),
prop_mating = sum(mating, na.rm = T)/sum(!is.na(mating)),
sex = unique(sex),
date = unique(date),
Treatment = unique(Treatment),
tank = unique(tank)) %>% ungroup()
View(df_mod)
unique(df_mod$mating)
data$mating <- ifelse(data$mating == "N" | data$mating == "C" | data$mating == "DEAD" |data$mating == "Dead?" |data$mating == "?" |data$mating == "<NA>" | data$mating == "OVI" |data$mating == "v" |data$mating == "ES" |data$mating == "O" |data$mating == "V", "0", "1")
View(data)
unique(data$Treatment)
unique(data$mating)
unique(data$activity)
class(data$activity)
unique(data$mating)
###change activity to binary
data$activity <- felse(data$activity == "1", "1", "0")
###change activity to binary
data$activity <- ifelse(data$activity == "1", "1", "0")
unique(data$activity)
df = data
df = df %>% group_by(date, tank, time) %>%
mutate(uniq_ids = paste0(sort(unique(id)), collapse = "_")) %>% ungroup()
tanksdays_changingstriders = df %>% group_by(date, tank) %>% summarize(n = length(unique(uniq_ids))) %>% ungroup()
tanksdays_changingstriders %>% filter(n > 1) #filter code filters the dataframe to those
#so, to eliminate these observations, use anti-join
#removes observations from df which are present in tanksdays...
df_mod = tanksdays_changingstriders %>% filter(n > 1) %>%
select(-n) %>% #this line removes the n column, which we no longer need
anti_join(df, ., by = c("date", "tank"))
(nrow(df) - nrow(df_mod))/nrow(df)
#df_mod contains observations where group membership does not change on a single day
#so now, let's calculate the unique groups labels, which is the unique combination
#of uniq_id and tank id
df_mod$groupID = paste0("group", df_mod$tank, " ", df_mod$uniq_ids)
#those groups
#to do this, I will group by our new "groupID" variable, and then sort the data
#within that grouping variable by "date", 'time', and 'id' so that when we add
#a new trial column according to date, we can be sure that the earliest date corresponds
#to the earliest trial
#this probably isn't necessary, assuming the data are already correctly sorted, but on the
#off chance that for some data the values are not entered chronologically, this code
#will prevent that from being an issue
#note that in the arrange code, the .by_group argument ensures that the data are arranged
#within their grouping category (rather than as a whole, regardless of grouping)
df_mod = df_mod %>% group_by(groupID) %>% arrange(date, time, id, .by_group = T) %>%
mutate(trial = as.integer(as.factor(date))) %>% ungroup()
#we have found that sex and treatment are problematic because there are multiple
#entries of sex and treatment for some groupID-trial-id combinations
test = df_mod %>% group_by(groupID, trial, id) %>%
summarize( n_treatment = length(unique(Treatment)),
n_sex = length(unique(sex))) %>% ungroup()
#fix issues with tanks who were assigned large treatment even though they are small
df_mod$Treatment <- as.character(df_mod$Treatment)
df_mod$Treatment <- ifelse(df_mod$groupID == "groupT20 144_157-G_160-R_161-B_39_97", "small", df_mod$Treatment)
#fix sex for individual 145-Y who was assigned male for one entry
df_mod$sex <- as.character(df_mod$sex)
df_mod$sex <- ifelse(df_mod$id == "145-Y", "F", df_mod$sex)
#and so now we want to calculate the proportion of time active and mating, within a day,
#for each male, for each of its observed trials, for each of its observed groups
#but remember that trial is the same thing as day
df_mod$activity <- as.numeric(df_mod$activity)
df_mod$mating <- as.numeric(df_mod$mating)
bloop = df_mod %>% group_by(groupID, trial, id) %>%
summarize(prop_active = sum(activity, na.rm = T)/sum(!is.na(activity)),
prop_mating = sum(mating, na.rm = T)/sum(!is.na(mating)),
sex = unique(sex),
date = unique(date),
Treatment = unique(Treatment),
tank = unique(tank)) %>% ungroup()
View(bloop)
unique(data$behavior)
###change behavior to binary
data$behavior <- ifelse(data$activity == "W" | data$activity == "WC" | data$activity == "WES" | data$activity == "WF" , "1", "0")
unique(data$behavior)
data <- read.csv("data.csv")
###change mating to binary
data$mating <- ifelse(data$mating == "N" | data$mating == "C" | data$mating == "DEAD" |data$mating == "Dead?" |data$mating == "?" |data$mating == "<NA>" | data$mating == "OVI" |data$mating == "v" |data$mating == "ES" |data$mating == "O" |data$mating == "V", "0", "1")
###change activity to binary
data$activity <- ifelse(data$activity == "1", "1", "0")
###change behavior to binary
data$behavior <- ifelse(data$behavior == "W" | data$behavior == "WC" | data$behavior == "WES" | data$behavior == "WF" , "1", "0")
unique(data$behavior)
df = data
df = df %>% group_by(date, tank, time) %>%
mutate(uniq_ids = paste0(sort(unique(id)), collapse = "_")) %>% ungroup()
tanksdays_changingstriders = df %>% group_by(date, tank) %>% summarize(n = length(unique(uniq_ids))) %>% ungroup()
tanksdays_changingstriders %>% filter(n > 1) #filter code filters the dataframe to those
#so, to eliminate these observations, use anti-join
#removes observations from df which are present in tanksdays...
df_mod = tanksdays_changingstriders %>% filter(n > 1) %>%
select(-n) %>% #this line removes the n column, which we no longer need
anti_join(df, ., by = c("date", "tank"))
(nrow(df) - nrow(df_mod))/nrow(df)
#df_mod contains observations where group membership does not change on a single day
#so now, let's calculate the unique groups labels, which is the unique combination
#of uniq_id and tank id
df_mod$groupID = paste0("group", df_mod$tank, " ", df_mod$uniq_ids)
#those groups
#to do this, I will group by our new "groupID" variable, and then sort the data
#within that grouping variable by "date", 'time', and 'id' so that when we add
#a new trial column according to date, we can be sure that the earliest date corresponds
#to the earliest trial
#this probably isn't necessary, assuming the data are already correctly sorted, but on the
#off chance that for some data the values are not entered chronologically, this code
#will prevent that from being an issue
#note that in the arrange code, the .by_group argument ensures that the data are arranged
#within their grouping category (rather than as a whole, regardless of grouping)
df_mod = df_mod %>% group_by(groupID) %>% arrange(date, time, id, .by_group = T) %>%
mutate(trial = as.integer(as.factor(date))) %>% ungroup()
#we have found that sex and treatment are problematic because there are multiple
#entries of sex and treatment for some groupID-trial-id combinations
test = df_mod %>% group_by(groupID, trial, id) %>%
summarize( n_treatment = length(unique(Treatment)),
n_sex = length(unique(sex))) %>% ungroup()
#fix issues with tanks who were assigned large treatment even though they are small
df_mod$Treatment <- as.character(df_mod$Treatment)
df_mod$Treatment <- ifelse(df_mod$groupID == "groupT20 144_157-G_160-R_161-B_39_97", "small", df_mod$Treatment)
#fix sex for individual 145-Y who was assigned male for one entry
df_mod$sex <- as.character(df_mod$sex)
df_mod$sex <- ifelse(df_mod$id == "145-Y", "F", df_mod$sex)
#and so now we want to calculate the proportion of time active and mating, within a day,
#for each male, for each of its observed trials, for each of its observed groups
#but remember that trial is the same thing as day
df_mod$activity <- as.numeric(df_mod$activity)
df_mod$mating <- as.numeric(df_mod$mating)
#and so now we want to calculate the proportion of time active and mating, within a day,
#for each male, for each of its observed trials, for each of its observed groups
#but remember that trial is the same thing as day
df_mod$behavior <- as.numeric(df_mod$behavior)
bloop = df_mod %>% group_by(groupID, trial, id) %>%
summarize(prop_active = sum(behavior, na.rm = T)/sum(!is.na(behavior)),
prop_mating = sum(mating, na.rm = T)/sum(!is.na(mating)),
sex = unique(sex),
date = unique(date),
Treatment = unique(Treatment),
tank = unique(tank)) %>% ungroup()
View(bloop)
bloop = df_mod %>% group_by(groupID, trial, id) %>%
summarize(prop_behavior = sum(behavior, na.rm = T)/sum(!is.na(behavior)),
prop_mating = sum(mating, na.rm = T)/sum(!is.na(mating)),
sex = unique(sex),
date = unique(date),
Treatment = unique(Treatment),
tank = unique(tank)) %>% ungroup()
View(bloop)
bloop = df_mod %>% group_by(date, id) %>%
summarize(prop_behavior = sum(behavior, na.rm = T)/sum(!is.na(behavior)),
prop_mating = sum(mating, na.rm = T)/sum(!is.na(mating)),
sex = unique(sex),
date = unique(date),
Treatment = unique(Treatment),
tank = unique(tank)) %>% ungroup()
bloop = df_mod %>% group_by(date, id) %>%
summarize(prop_behavior = sum(behavior, na.rm = T)/sum(!is.na(behavior)),
prop_mating = sum(mating, na.rm = T)/sum(!is.na(mating)),
sex = unique(sex),
Treatment = unique(Treatment),
tank = unique(tank)) %>% ungroup()
#we have found that sex and treatment are problematic because there are multiple
#entries of sex and treatment for some groupID-trial-id combinations
test = df_mod %>% group_by(groupID, trial, id) %>%
summarize( n_treatment = length(unique(Treatment)),
n_sex = length(unique(sex))) %>% ungroup()
View(test)
#we have found that sex and treatment are problematic because there are multiple
#entries of sex and treatment for some groupID-trial-id combinations
test = df_mod %>% group_by(groupID, trial, id) %>%
summarize( n_treatment = length(unique(Treatment)),
n_sex = length(unique(sex))) %>% ungroup()
#fix issues with tanks who were assigned large treatment even though they are small
df_mod$Treatment <- as.character(df_mod$Treatment)
df_mod$Treatment <- ifelse(df_mod$groupID == "groupT20 144_157-G_160-R_161-B_39_97", "small", df_mod$Treatment)
#fix sex for individual 145-Y who was assigned male for one entry
df_mod$sex <- as.character(df_mod$sex)
df_mod$sex <- ifelse(df_mod$id == "145-Y", "F", df_mod$sex)
bloop = df_mod %>% group_by(date, id) %>%
summarize(prop_behavior = sum(behavior, na.rm = T)/sum(!is.na(behavior)),
prop_mating = sum(mating, na.rm = T)/sum(!is.na(mating)),
sex = unique(sex),
Treatment = unique(Treatment),
tank = unique(tank)) %>% ungroup()
test = df_mod %>% group_by(date, id) %>%
summarize( n_treatment = length(unique(Treatment)),
n_sex = length(unique(sex))) %>% ungroup()
View(test)
View(df_mod)
View(test)
View(test)
###exclude strider 98-Y because they they have a lot of contradicting data
test = df_mod %>% group_by(date, id) %>%
summarize( n_treatment = length(unique(Treatment)),
n_sex = length(unique(sex))) %>% ungroup()
View(test)
df_mod = test %>% filter(id == "98-Y") %>%
select(-n) %>% #this line removes the n column, which we no longer need
anti_join(df, ., by = c("date", "tank"))
df_mod = test %>% filter(id == "98-Y") %>%
select(-n_sex, -n_treatment) %>% #this line removes the n column, which we no longer need
anti_join(df, ., by = c("date", "tank"))
df_mod = test %>% filter(id == "98-Y") %>%
select(-n_sex, -n_treatment) %>% #this line removes the n column, which we no longer need
anti_join(df_mod, ., by = c("date", "tank"))
df_mod = test %>% filter(id == "98-Y") %>%
select(-n_sex, -n_treatment) %>% #this line removes the n column, which we no longer need
anti_join(df_mod, ., by = c("date", "id"))
bloop = df_mod %>% group_by(date, id) %>%
summarize(prop_behavior = sum(behavior, na.rm = T)/sum(!is.na(behavior)),
prop_mating = sum(mating, na.rm = T)/sum(!is.na(mating)),
sex = unique(sex),
Treatment = unique(Treatment),
tank = unique(tank)) %>% ungroup()
###exclude strider 98-Y because they they have a lot of contradicting data
test = df_mod %>% group_by(date, id) %>%
summarize( n_treatment = length(unique(Treatment)),
n_sex = length(unique(sex))) %>% ungroup()
View(test)
View(test)
View(df_mod %>% filter(date == "20130420" & id == "13"))
View(df_mod %>% filter(date == "20130420" & id == "13"))
View(df_mod %>% filter(date == "20130420" & id == "13"))
###exclude striders who have multiple entries
test = df_mod %>% group_by(date, id) %>%
summarize( n_treatment = length(unique(Treatment)),
n_sex = length(unique(sex))) %>% ungroup()
View(test)
###exclude striders who have multiple entries
test = df_mod %>% group_by(date, id) %>%
summarize( n_treatment = length(unique(Treatment)),
n_sex = length(unique(sex))) %>% ungroup()
View(test)
df_mod = test %>% filter(n_treatment > 1) %>%
select(-n_sex, -n_treatment) %>% #this line removes the n column, which we no longer need
anti_join(df_mod, ., by = c("date", "id"))
bloop = df_mod %>% group_by(date, id) %>%
summarize(prop_behavior = sum(behavior, na.rm = T)/sum(!is.na(behavior)),
prop_mating = sum(mating, na.rm = T)/sum(!is.na(mating)),
sex = unique(sex),
Treatment = unique(Treatment),
tank = unique(tank)) %>% ungroup()
###exclude striders who have multiple entries
test = df_mod %>% group_by(date, id) %>%
summarize( n_treatment = length(unique(Treatment)),
n_sex = length(unique(sex)), n_tank = length(unique(tank))) %>% ungroup()
View(test)
df_mod = test %>% filter(n_tank > 1) %>%
select(-n_sex, -n_treatment, -n_tank) %>% #this line removes the n column, which we no longer need
anti_join(df_mod, ., by = c("date", "id"))
bloop = df_mod %>% group_by(date, id) %>%
summarize(prop_behavior = sum(behavior, na.rm = T)/sum(!is.na(behavior)),
prop_mating = sum(mating, na.rm = T)/sum(!is.na(mating)),
sex = unique(sex),
Treatment = unique(Treatment),
tank = unique(tank)) %>% ungroup()
View(bloop)
unique(df_mod$tank)
rm(list = ls())
library(lme4)
library(MCMCglmm)
library(tidyverse)
library(broom)
library(nadiv)
df_syndrome <- read_csv("syndrome.csv")
###first assign an uninformative prior; later you should check your model results
prior_E_B_1px = list(R = list(V = diag(2), nu = 0.002),
G = list(G1 = list(V = diag(2), nu = 2, alpha.mu = rep(0,2),
alpha.V = diag(25^2,2,2))))
####set up model with bivariate response variable being boldness and exploration bound together using cbind
#scale response variables as well (centered around the mean and standarized to units of 1 phenotypic standard deviation)
mcmc_E_B_us <- MCMCglmm(cbind(scale(exploration), scale(boldness)) ~ trait-1 + trait:scale(assay_rep, scale = FALSE) +
trait:scale(body_size), #we use the trait keyword to specify that this is a multivariate model, trait-1 tells the model to give us a distinct intercept for each trait; we interact trait with the fixed effects so that we get estimates for the effect of these variables on each of our behaviors
random =~ us(trait):ID, #tells the model to fit an unstructured covariance matrix for the grouping variable ID, essentially we are calculating the variance in exploration due differences among individuals, the variance in boldness due to differences among individuals and the covariances between these variances
rcov =~ us(trait):units, #residual variance = within individual variation, because we have repeated measures for both traits at the individual level we also set aan unstructured covariance matrix; finds the residual variance for each trait and allows these variances to covary (???????)
family = c("gaussian","gaussian"),
prior = prior_E_B_1px, #include model priors
nitt=420000, #total number of iterations
burnin=20000, #number of iterations to discard as the model starts
thin=100, #number of iterations to discard inbetween successive stored samples, helps to reduce autocorrelation in sampling
verbose = TRUE,
data = as.data.frame(df_syndrome))
plot(mcmc_E_B_us$VCV)
summary(mcmc_E_B_us)
data <- read.csv("data1.csv")
###change mating to binary
data$mating <- ifelse(data$mating == "N" | data$mating == "C" | data$mating == "DEAD" |data$mating == "Dead?" |data$mating == "?" |data$mating == "<NA>" | data$mating == "OVI" |data$mating == "v" |data$mating == "ES" |data$mating == "O" |data$mating == "V", "0", "1")
###change activity to binary
data$activity <- ifelse(data$activity == "1", "1", "0")
###change behavior to binary
data$behavior <- ifelse(data$behavior == "W" | data$behavior == "WC" | data$behavior == "WES" | data$behavior == "WF" , "1", "0")
View(data)
library(dplyr)
###calculate "behavior" and "mating" for each strider for each trial
test <- data %>% group_by(id) %>% group_by(period) %>% summary(sum(behavior)) %>% ungroup
###calculate "behavior" and "mating" for each strider for each trial
test <- data %>% group_by(id) %>% group_by(period) %>% summary(sum(data$behavior)) %>% ungroup
class(data$behavior)
###calculate "behavior" and "mating" for each strider for each trial
data$behavior <- as.numeric(data$behavior)
data$mating <- as.numeric(data$mating)
test <- data %>% group_by(id) %>% group_by(period) %>% summary(sum(behavior)) %>% ungroup
test <- data %>% group_by(id) %>% group_by(period) %>% summary(sum(data$behavior)) %>% ungroup
test <- data %>% group_by(id) %>% group_by(period) %>% na.omit(.) %>% summary(sum(data$behavior)) %>% ungroup
?mutate
test <- data %>% group_by(id, period) %>% na.omit() %>% summary(sum(data$behavior)) %>% ungroup
sum(data$behavior)
test <- na.omit(data$behavior)
sum(test)
test <- data %>% group_by(id, period) %>% na.omit(.) %>% summary(sum(data$behavior)) %>% ungroup
test <- data %>% group_by(id, period) %>% na.omit(.) %>% summary(sum(.)) %>% ungroup
test <- data %>% group_by(id, period) %>% na.omit(.) %>% summary(sum(behavior)) %>% ungroup
test <- data %>% group_by(id, period) %>% na.omit(.) %>% summarize(sum(behavior)) %>% ungroup
View(test)
df <- data %>% group_by(id, period) %>% na.omit(.) %>% summarize(sum(behavior)) %>% ungroup
mating <- data %>% group_by(id, period) %>% na.omit(.) %>% summarize(sum(mating)) %>% ungroup
View(mating)
df <- merge(df, mating = mating[ , c("id", "sum(mating)")], by = "id", all.x=TRUE)
df <- merge(x = df, y = mating = mating[ , c("id", "sum(mating)")], by = "id", all.x=TRUE)
df <- merge(x = df, y = mating[ , c("id", "sum(mating)")], by = "id", all.x=TRUE)
View(df)
#add sex, and treatment to data frame
test <- merge(x = df, y = data[, c("id", "sex", "small")], by = "id", all.x = TRUE)
View(test)
#add sex, and treatment to data frame
test <- left_join(x = df, y = data[, c("id", "sex", "small")], by = "id", all.x = TRUE)
#add sex, and treatment to data frame
test <- merge(x = df, y = data[, c("id", "sex", "small")], by = "id")
#add sex, and treatment to data frame
test <- left_join(df, data, by = "id")
#add sex, and treatment to data frame
test <- left_join(df, data, by = "id")
#add sex, and treatment to data frame
test <- merge(df, data, by = "id")
rm(test)
#add sex, and treatment to data frame
test <- left_join(df, data, by = "id")
#create new data frame with summed behavior for each individual in each trial
df <- data %>% group_by(id, period) %>% na.omit(.) %>% summarize(sum(behavior)) %>% summarize(sum(behavior) %>% ungroup
#create new data frame with summed behavior for each individual in each trial
df <- data %>% group_by(id, period) %>% na.omit(.) %>% summarize(sum(behavior)) %>% summarize(sum(behavior)) %>% ungroup
#create new data frame with summed behavior for each individual in each trial
df <- data %>% group_by(id, period) %>% na.omit(.) %>% summarize(sum(behavior)) %>% summarize(sum(mating)) %>% ungroup
#create new data frame with summed behavior for each individual in each trial
df <- data %>% group_by(id, period) %>% na.omit(.) %>% summarize(sum(behavior & mating)) %>% ungroup
View(df)
#create new data frame with summed behavior for each individual in each trial
df <- data %>% group_by(id, period) %>% na.omit(.) %>% summarize(sum(behavior)) & summarize(sum(behavior)) %>% ungroup
#create new data frame with summed behavior for each individual in each trial
df <- data %>% group_by(id, period) %>% na.omit(.) %>% summarize(sum(behavior)) & summarize(sum(mating)) %>% ungroup
###sum "behavior" and "mating" for each strider for each trial
#vectors have to be numeric in order to sum
data$behavior <- as.numeric(data$behavior)
data$mating <- as.numeric(data$mating)
#create new data frame with summed behavior for each individual in each trial
df <- data %>% group_by(id, period) %>% na.omit(.) %>% summarize(sum(behavior)) & summarize(sum(mating)) %>% ungroup
#data frame with sex
mating <- data %>% group_by(id) %>% summarize(sex) %>% ungroup
#data frame with sex
sex <- data %>% group_by(id, period) %>% summarize(sex) %>% ungroup
#data frame with sex
sex <- data %>% group_by(id, period) %>% summarize(sex) %>% ungroup
#data frame with sex
sex <- data %>% group_by(id, period) %>% summarize(unique(sex)) %>% ungroup
#data frame with sex
sex <- data %>% group_by(id, period) %>% summarize(length(unique(sex))) %>% ungroup
View(sex)
data <- read.csv("data1.csv")
###change mating to binary
data$mating <- ifelse(data$mating == "N" | data$mating == "C" | data$mating == "DEAD" |data$mating == "Dead?" |data$mating == "?" |data$mating == "<NA>" | data$mating == "OVI" |data$mating == "v" |data$mating == "ES" |data$mating == "O" |data$mating == "V", "0", "1")
###change activity to binary
data$activity <- ifelse(data$activity == "1", "1", "0")
###change behavior to binary
data$behavior <- ifelse(data$behavior == "W" | data$behavior == "WC" | data$behavior == "WES" | data$behavior == "WF" , "1", "0")
###sum "behavior" and "mating" for each strider for each trial
#vectors have to be numeric in order to sum
data$behavior <- as.numeric(data$behavior)
data$mating <- as.numeric(data$mating)
#create new data frame with summed behavior for each individual in each trial
df <- data %>% group_by(id, period) %>% na.omit(.) %>% summarize(sum(behavior)) %>% ungroup
#sum mating for each individual in each trial
mating <- data %>% group_by(id) %>% na.omit(.) %>% summarize(sum(mating)) %>% ungroup
#data frame with sex
#first check that each individual has only one entry for sex
sex <- data %>% group_by(id, period) %>% summarize(length(unique(sex))) %>% ungroup #some of them have two so I corrected the entries in excel
View(sex)
library(dplyr)
data <- read.csv("data1.csv")
###change mating to binary
data$mating <- ifelse(data$mating == "N" | data$mating == "C" | data$mating == "DEAD" |data$mating == "Dead?" |data$mating == "?" |data$mating == "<NA>" | data$mating == "OVI" |data$mating == "v" |data$mating == "ES" |data$mating == "O" |data$mating == "V", "0", "1")
###change activity to binary
data$activity <- ifelse(data$activity == "1", "1", "0")
###change behavior to binary
data$behavior <- ifelse(data$behavior == "W" | data$behavior == "WC" | data$behavior == "WES" | data$behavior == "WF" , "1", "0")
###sum "behavior" and "mating" for each strider for each trial
#vectors have to be numeric in order to sum
data$behavior <- as.numeric(data$behavior)
data$mating <- as.numeric(data$mating)
#create new data frame with summed behavior for each individual in each trial
df <- data %>% group_by(id, period) %>% na.omit(.) %>% summarize(sum(behavior)) %>% ungroup
#sum mating for each individual in each trial
mating <- data %>% group_by(id) %>% na.omit(.) %>% summarize(sum(mating)) %>% ungroup
#data frame with sex
#first check that each individual has only one entry for sex
sex <- data %>% group_by(id, period) %>% summarize(length(unique(sex))) %>% ungroup #some of them have two so I corrected the entries in excel
View(sex)
data <- read.csv("data1.csv")
###change mating to binary
data$mating <- ifelse(data$mating == "N" | data$mating == "C" | data$mating == "DEAD" |data$mating == "Dead?" |data$mating == "?" |data$mating == "<NA>" | data$mating == "OVI" |data$mating == "v" |data$mating == "ES" |data$mating == "O" |data$mating == "V", "0", "1")
###change activity to binary
data$activity <- ifelse(data$activity == "1", "1", "0")
###change behavior to binary
data$behavior <- ifelse(data$behavior == "W" | data$behavior == "WC" | data$behavior == "WES" | data$behavior == "WF" , "1", "0")
###sum "behavior" and "mating" for each strider for each trial
#vectors have to be numeric in order to sum
data$behavior <- as.numeric(data$behavior)
data$mating <- as.numeric(data$mating)
#create new data frame with summed behavior for each individual in each trial
df <- data %>% group_by(id, period) %>% na.omit(.) %>% summarize(sum(behavior)) %>% ungroup
#sum mating for each individual in each trial
mating <- data %>% group_by(id) %>% na.omit(.) %>% summarize(sum(mating)) %>% ungroup
#data frame with sex
#first check that each individual has only one entry for sex
sex <- data %>% group_by(id, period) %>% summarize(length(unique(sex))) %>% ungroup #some of them have two so I corrected the entries in excel
View(sex)
#no that it's corrected make a sex data frame to merge
sex <- data %>% group_by(id, period) %>% summarize(sex) %>% ungroup
#no that it's corrected make a sex data frame to merge
sex <- data %>% group_by(id) %>% summarize(sex) %>% ungroup
#no that it's corrected make a sex data frame to merge
sex <- data %>% group_by(id) %>% summarize(unique(sex)) %>% ungroup
View(sex)
#data frame with sex
#first check that each individual has only one entry for sex
sex <- data %>% group_by(id) %>% summarize(length(unique(sex))) %>% ungroup #some of them have two so I corrected the entries in excel
View(sex)
data <- read.csv("data1.csv")
###change mating to binary
data$mating <- ifelse(data$mating == "N" | data$mating == "C" | data$mating == "DEAD" |data$mating == "Dead?" |data$mating == "?" |data$mating == "<NA>" | data$mating == "OVI" |data$mating == "v" |data$mating == "ES" |data$mating == "O" |data$mating == "V", "0", "1")
###change activity to binary
data$activity <- ifelse(data$activity == "1", "1", "0")
###change behavior to binary
data$behavior <- ifelse(data$behavior == "W" | data$behavior == "WC" | data$behavior == "WES" | data$behavior == "WF" , "1", "0")
###sum "behavior" and "mating" for each strider for each trial
#vectors have to be numeric in order to sum
data$behavior <- as.numeric(data$behavior)
data$mating <- as.numeric(data$mating)
#create new data frame with summed behavior for each individual in each trial
df <- data %>% group_by(id, period) %>% na.omit(.) %>% summarize(sum(behavior)) %>% ungroup
#sum mating for each individual in each trial
mating <- data %>% group_by(id) %>% na.omit(.) %>% summarize(sum(mating)) %>% ungroup
#data frame with sex
#first check that each individual has only one entry for sex
sex <- data %>% group_by(id) %>% summarize(length(unique(sex))) %>% ungroup #some of them have two so I corrected the entries in excel
View(sex)
#no that it's corrected make a sex data frame to merge
sex <- data %>% group_by(id) %>% summarize(unique(sex)) %>% ungroup
View(sex)
#add sex to behavior data frame
df <- merge(x = df, y = sex, by = "id")
View(df)
#data frame with treatment
treatment <- data %>% group_by(id, period) %>% summarize(unique(small)) %>% ungroup
#data frame with treatment
#first check that each individual has only one treatment entry for each trial period
sex <- data %>% group_by(id, period) %>% summarize(length(unique(treatment))) %>% ungroup
#data frame with treatment
#first check that each individual has only one treatment entry for each trial period
sex <- data %>% group_by(id, period) %>% summarize(length(unique(small))) %>% ungroup
View(sex)
