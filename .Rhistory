summarize(prop_active = sum(activity, na.rm = T)/sum(!is.na(activity)),
prop_mating = sum(mating, na.rm = T)/sum(!is.na(mating)),
#sex = unique(sex))
date = unique(date))
#and so now we want to calculate the proportion of time active and mating, within a day,
#for each male, for each of its observed trials, for each of its observed groups
#but remember that trial is the same thing as day
test = df_mod %>% group_by(groupID, trial, id) %>%
summarize(prop_active = sum(activity, na.rm = T)/sum(!is.na(activity)),
prop_mating = sum(mating, na.rm = T)/sum(!is.na(mating)),
#sex = unique(sex))
date = unique(date),
tank = unique(tank))
#and so now we want to calculate the proportion of time active and mating, within a day,
#for each male, for each of its observed trials, for each of its observed groups
#but remember that trial is the same thing as day
test = df_mod %>% group_by(groupID, trial, id) %>%
summarize(prop_active = sum(activity, na.rm = T)/sum(!is.na(activity)),
prop_mating = sum(mating, na.rm = T)/sum(!is.na(mating)),
#sex = unique(sex))
date = unique(date),
tank = unique(tank),
Treatment = unique(Treatment)) %>% ungroup()
test = df_mod %>% group_by(groupID, trial, id) %>%
summarize( n_treatment = length(unique(Treatment)),
n_sex = length(unique(sex))) %>% ungroup()
View(test)
#and so now we want to calculate the proportion of time active and mating, within a day,
#for each male, for each of its observed trials, for each of its observed groups
#but remember that trial is the same thing as day
df_mod = df_mod %>% group_by(groupID, trial, id) %>%
summarize(prop_active = sum(activity, na.rm = T)/sum(!is.na(activity)),
prop_mating = sum(mating, na.rm = T)/sum(!is.na(mating)),
#sex = unique(sex))
date = unique(date),
#Treatment = unique(Treatment),
tank = unique(tank)) %>% ungroup()
View(df_mod)
View(test)
View(test)
View(data)
View(df)
df = data
df = df %>% group_by(date, tank, time) %>%
mutate(uniq_ids = paste0(sort(unique(id)), collapse = "_")) %>% ungroup()
tanksdays_changingstriders = df %>% group_by(date, tank) %>% summarize(n = length(unique(uniq_ids))) %>% ungroup()
tanksdays_changingstriders %>% filter(n > 1) #filter code filters the dataframe to those
#so, to eliminate these observations, use anti-join
#removes observations from df which are present in tanksdays...
df_mod = tanksdays_changingstriders %>% filter(n > 1) %>%
select(-n) %>% #this line removes the n column, which we no longer need
anti_join(df, ., by = c("date", "tank"))
(nrow(df) - nrow(df_mod))/nrow(df)
#df_mod contains observations where group membership does not change on a single day
#so now, let's calculate the unique groups labels, which is the unique combination
#of uniq_id and tank id
df_mod$groupID = paste0("group", df_mod$tank, " ", df_mod$uniq_ids)
#those groups
#to do this, I will group by our new "groupID" variable, and then sort the data
#within that grouping variable by "date", 'time', and 'id' so that when we add
#a new trial column according to date, we can be sure that the earliest date corresponds
#to the earliest trial
#this probably isn't necessary, assuming the data are already correctly sorted, but on the
#off chance that for some data the values are not entered chronologically, this code
#will prevent that from being an issue
#note that in the arrange code, the .by_group argument ensures that the data are arranged
#within their grouping category (rather than as a whole, regardless of grouping)
df_mod = df_mod %>% group_by(groupID) %>% arrange(date, time, id, .by_group = T) %>%
mutate(trial = as.integer(as.factor(date))) %>% ungroup()
#fix issues with tanks who were assigned large treatment even though they are small
df_mod$Treatment <- ifelse(df_mod$groupID == "groupT20 144_157-G_160-R_161-B_39_97", df_mod$Treatment == "small",  df_mod$Treatment = df_mod$Treatment)
#fix issues with tanks who were assigned large treatment even though they are small
df_mod$Treatment <- ifelse(df_mod$groupID == "groupT20 144_157-G_160-R_161-B_39_97", "small", df_mod$Treatment)
#fix sex for individual 145-Y who was assigned male for one entry
df_mod$sex <- ifelse(df_mod$id == "145-Y", "f", df_mod$sex)
#and so now we want to calculate the proportion of time active and mating, within a day,
#for each male, for each of its observed trials, for each of its observed groups
#but remember that trial is the same thing as day
df_mod = df_mod %>% group_by(groupID, trial, id) %>%
summarize(prop_active = sum(activity, na.rm = T)/sum(!is.na(activity)),
prop_mating = sum(mating, na.rm = T)/sum(!is.na(mating)),
#sex = unique(sex))
date = unique(date),
#Treatment = unique(Treatment),
tank = unique(tank)) %>% ungroup()
#so, to eliminate these observations, use anti-join
#removes observations from df which are present in tanksdays...
df_mod = tanksdays_changingstriders %>% filter(n > 1) %>%
select(-n) %>% #this line removes the n column, which we no longer need
anti_join(df, ., by = c("date", "tank"))
(nrow(df) - nrow(df_mod))/nrow(df)
#df_mod contains observations where group membership does not change on a single day
#so now, let's calculate the unique groups labels, which is the unique combination
#of uniq_id and tank id
df_mod$groupID = paste0("group", df_mod$tank, " ", df_mod$uniq_ids)
#those groups
#to do this, I will group by our new "groupID" variable, and then sort the data
#within that grouping variable by "date", 'time', and 'id' so that when we add
#a new trial column according to date, we can be sure that the earliest date corresponds
#to the earliest trial
#this probably isn't necessary, assuming the data are already correctly sorted, but on the
#off chance that for some data the values are not entered chronologically, this code
#will prevent that from being an issue
#note that in the arrange code, the .by_group argument ensures that the data are arranged
#within their grouping category (rather than as a whole, regardless of grouping)
df_mod = df_mod %>% group_by(groupID) %>% arrange(date, time, id, .by_group = T) %>%
mutate(trial = as.integer(as.factor(date))) %>% ungroup()
#we have found that sex and treatment are problematic because there are multiple
#entries of sex and treatment for some groupID-trial-id combinations
test = df_mod %>% group_by(groupID, trial, id) %>%
summarize( n_treatment = length(unique(Treatment)),
n_sex = length(unique(sex))) %>% ungroup()
#fix issues with tanks who were assigned large treatment even though they are small
df_mod$Treatment <- ifelse(df_mod$groupID == "groupT20 144_157-G_160-R_161-B_39_97", "small", df_mod$Treatment)
#fix sex for individual 145-Y who was assigned male for one entry
df_mod$sex <- ifelse(df_mod$id == "145-Y", "f", df_mod$sex)
#and so now we want to calculate the proportion of time active and mating, within a day,
#for each male, for each of its observed trials, for each of its observed groups
#but remember that trial is the same thing as day
df_mod = df_mod %>% group_by(groupID, trial, id) %>%
summarize(prop_active = sum(activity, na.rm = T)/sum(!is.na(activity)),
prop_mating = sum(mating, na.rm = T)/sum(!is.na(mating)),
sex = unique(sex))
df_mod = df_mod %>% group_by(groupID, trial, id) %>%
summarize(prop_active = sum(activity, na.rm = T)/sum(!is.na(activity)),
prop_mating = sum(mating, na.rm = T)/sum(!is.na(mating)),
sex = unique(sex)),
date = unique(date),
Treatment = unique(Treatment),
tank = unique(tank)) %>% ungroup()
#so, to eliminate these observations, use anti-join
#removes observations from df which are present in tanksdays...
df_mod = tanksdays_changingstriders %>% filter(n > 1) %>%
select(-n) %>% #this line removes the n column, which we no longer need
anti_join(df, ., by = c("date", "tank"))
(nrow(df) - nrow(df_mod))/nrow(df)
#df_mod contains observations where group membership does not change on a single day
#so now, let's calculate the unique groups labels, which is the unique combination
#of uniq_id and tank id
df_mod$groupID = paste0("group", df_mod$tank, " ", df_mod$uniq_ids)
#those groups
#to do this, I will group by our new "groupID" variable, and then sort the data
#within that grouping variable by "date", 'time', and 'id' so that when we add
#a new trial column according to date, we can be sure that the earliest date corresponds
#to the earliest trial
#this probably isn't necessary, assuming the data are already correctly sorted, but on the
#off chance that for some data the values are not entered chronologically, this code
#will prevent that from being an issue
#note that in the arrange code, the .by_group argument ensures that the data are arranged
#within their grouping category (rather than as a whole, regardless of grouping)
df_mod = df_mod %>% group_by(groupID) %>% arrange(date, time, id, .by_group = T) %>%
mutate(trial = as.integer(as.factor(date))) %>% ungroup()
#we have found that sex and treatment are problematic because there are multiple
#entries of sex and treatment for some groupID-trial-id combinations
test = df_mod %>% group_by(groupID, trial, id) %>%
summarize( n_treatment = length(unique(Treatment)),
n_sex = length(unique(sex))) %>% ungroup()
#fix issues with tanks who were assigned large treatment even though they are small
df_mod$Treatment <- ifelse(df_mod$groupID == "groupT20 144_157-G_160-R_161-B_39_97", "small", df_mod$Treatment)
#fix sex for individual 145-Y who was assigned male for one entry
df_mod$sex <- ifelse(df_mod$id == "145-Y", "f", df_mod$sex)
#and so now we want to calculate the proportion of time active and mating, within a day,
#for each male, for each of its observed trials, for each of its observed groups
#but remember that trial is the same thing as day
df_mod = df_mod %>% group_by(groupID, trial, id) %>%
summarize(prop_active = sum(activity, na.rm = T)/sum(!is.na(activity)),
prop_mating = sum(mating, na.rm = T)/sum(!is.na(mating)),
sex = unique(sex),
date = unique(date),
Treatment = unique(Treatment),
tank = unique(tank)) %>% ungroup()
View(df_mod)
df = data
df = df %>% group_by(date, tank, time) %>%
mutate(uniq_ids = paste0(sort(unique(id)), collapse = "_")) %>% ungroup()
tanksdays_changingstriders = df %>% group_by(date, tank) %>% summarize(n = length(unique(uniq_ids))) %>% ungroup()
tanksdays_changingstriders %>% filter(n > 1) #filter code filters the dataframe to those
#so, to eliminate these observations, use anti-join
#removes observations from df which are present in tanksdays...
df_mod = tanksdays_changingstriders %>% filter(n > 1) %>%
select(-n) %>% #this line removes the n column, which we no longer need
anti_join(df, ., by = c("date", "tank"))
(nrow(df) - nrow(df_mod))/nrow(df)
#df_mod contains observations where group membership does not change on a single day
#so now, let's calculate the unique groups labels, which is the unique combination
#of uniq_id and tank id
df_mod$groupID = paste0("group", df_mod$tank, " ", df_mod$uniq_ids)
#those groups
#to do this, I will group by our new "groupID" variable, and then sort the data
#within that grouping variable by "date", 'time', and 'id' so that when we add
#a new trial column according to date, we can be sure that the earliest date corresponds
#to the earliest trial
#this probably isn't necessary, assuming the data are already correctly sorted, but on the
#off chance that for some data the values are not entered chronologically, this code
#will prevent that from being an issue
#note that in the arrange code, the .by_group argument ensures that the data are arranged
#within their grouping category (rather than as a whole, regardless of grouping)
df_mod = df_mod %>% group_by(groupID) %>% arrange(date, time, id, .by_group = T) %>%
mutate(trial = as.integer(as.factor(date))) %>% ungroup()
#we have found that sex and treatment are problematic because there are multiple
#entries of sex and treatment for some groupID-trial-id combinations
test = df_mod %>% group_by(groupID, trial, id) %>%
summarize( n_treatment = length(unique(Treatment)),
n_sex = length(unique(sex))) %>% ungroup()
View(test)
#fix issues with tanks who were assigned large treatment even though they are small
df_mod$Treatment <- ifelse(df_mod$groupID == "groupT20 144_157-G_160-R_161-B_39_97", "small", df_mod$Treatment)
#fix sex for individual 145-Y who was assigned male for one entry
df_mod$sex <- ifelse(df_mod$id == "145-Y", "F", df_mod$sex)
#we have found that sex and treatment are problematic because there are multiple
#entries of sex and treatment for some groupID-trial-id combinations
test = df_mod %>% group_by(groupID, trial, id) %>%
summarize( n_treatment = length(unique(Treatment)),
n_sex = length(unique(sex))) %>% ungroup()
#and so now we want to calculate the proportion of time active and mating, within a day,
#for each male, for each of its observed trials, for each of its observed groups
#but remember that trial is the same thing as day
df_mod = df_mod %>% group_by(groupID, trial, id) %>%
summarize(prop_active = sum(activity, na.rm = T)/sum(!is.na(activity)),
prop_mating = sum(mating, na.rm = T)/sum(!is.na(mating)),
sex = unique(sex),
date = unique(date),
Treatment = unique(Treatment),
tank = unique(tank)) %>% ungroup()
View(df_mod)
df = data
df = df %>% group_by(date, tank, time) %>%
mutate(uniq_ids = paste0(sort(unique(id)), collapse = "_")) %>% ungroup()
tanksdays_changingstriders = df %>% group_by(date, tank) %>% summarize(n = length(unique(uniq_ids))) %>% ungroup()
tanksdays_changingstriders %>% filter(n > 1) #filter code filters the dataframe to those
#so, to eliminate these observations, use anti-join
#removes observations from df which are present in tanksdays...
df_mod = tanksdays_changingstriders %>% filter(n > 1) %>%
select(-n) %>% #this line removes the n column, which we no longer need
anti_join(df, ., by = c("date", "tank"))
(nrow(df) - nrow(df_mod))/nrow(df)
#df_mod contains observations where group membership does not change on a single day
#so now, let's calculate the unique groups labels, which is the unique combination
#of uniq_id and tank id
df_mod$groupID = paste0("group", df_mod$tank, " ", df_mod$uniq_ids)
#those groups
#to do this, I will group by our new "groupID" variable, and then sort the data
#within that grouping variable by "date", 'time', and 'id' so that when we add
#a new trial column according to date, we can be sure that the earliest date corresponds
#to the earliest trial
#this probably isn't necessary, assuming the data are already correctly sorted, but on the
#off chance that for some data the values are not entered chronologically, this code
#will prevent that from being an issue
#note that in the arrange code, the .by_group argument ensures that the data are arranged
#within their grouping category (rather than as a whole, regardless of grouping)
df_mod = df_mod %>% group_by(groupID) %>% arrange(date, time, id, .by_group = T) %>%
mutate(trial = as.integer(as.factor(date))) %>% ungroup()
#we have found that sex and treatment are problematic because there are multiple
#entries of sex and treatment for some groupID-trial-id combinations
test = df_mod %>% group_by(groupID, trial, id) %>%
summarize( n_treatment = length(unique(Treatment)),
n_sex = length(unique(sex))) %>% ungroup()
#fix issues with tanks who were assigned large treatment even though they are small
df_mod$Treatment <- ifelse(df_mod$groupID == "groupT20 144_157-G_160-R_161-B_39_97", "small", df_mod$Treatment)
df = data
df = df %>% group_by(date, tank, time) %>%
mutate(uniq_ids = paste0(sort(unique(id)), collapse = "_")) %>% ungroup()
tanksdays_changingstriders = df %>% group_by(date, tank) %>% summarize(n = length(unique(uniq_ids))) %>% ungroup()
tanksdays_changingstriders %>% filter(n > 1) #filter code filters the dataframe to those
#so, to eliminate these observations, use anti-join
#removes observations from df which are present in tanksdays...
df_mod = tanksdays_changingstriders %>% filter(n > 1) %>%
select(-n) %>% #this line removes the n column, which we no longer need
anti_join(df, ., by = c("date", "tank"))
(nrow(df) - nrow(df_mod))/nrow(df)
#df_mod contains observations where group membership does not change on a single day
#so now, let's calculate the unique groups labels, which is the unique combination
#of uniq_id and tank id
df_mod$groupID = paste0("group", df_mod$tank, " ", df_mod$uniq_ids)
#those groups
#to do this, I will group by our new "groupID" variable, and then sort the data
#within that grouping variable by "date", 'time', and 'id' so that when we add
#a new trial column according to date, we can be sure that the earliest date corresponds
#to the earliest trial
#this probably isn't necessary, assuming the data are already correctly sorted, but on the
#off chance that for some data the values are not entered chronologically, this code
#will prevent that from being an issue
#note that in the arrange code, the .by_group argument ensures that the data are arranged
#within their grouping category (rather than as a whole, regardless of grouping)
df_mod = df_mod %>% group_by(groupID) %>% arrange(date, time, id, .by_group = T) %>%
mutate(trial = as.integer(as.factor(date))) %>% ungroup()
#we have found that sex and treatment are problematic because there are multiple
#entries of sex and treatment for some groupID-trial-id combinations
test = df_mod %>% group_by(groupID, trial, id) %>%
summarize( n_treatment = length(unique(Treatment)),
n_sex = length(unique(sex))) %>% ungroup()
#fix issues with tanks who were assigned large treatment even though they are small
df_mod$Treatment <- if(df_mod$groupID == "groupT20 144_157-G_160-R_161-B_39_97", "small")
"small"}
df_mod$Treatment <- if(df_mod$groupID == "groupT20 144_157-G_160-R_161-B_39_97") {
print("small")
}
#we have found that sex and treatment are problematic because there are multiple
#entries of sex and treatment for some groupID-trial-id combinations
test = df_mod %>% group_by(groupID, trial, id) %>%
summarize( n_treatment = length(unique(Treatment)),
n_sex = length(unique(sex))) %>% ungroup()
df = data
df = df %>% group_by(date, tank, time) %>%
mutate(uniq_ids = paste0(sort(unique(id)), collapse = "_")) %>% ungroup()
tanksdays_changingstriders = df %>% group_by(date, tank) %>% summarize(n = length(unique(uniq_ids))) %>% ungroup()
tanksdays_changingstriders %>% filter(n > 1) #filter code filters the dataframe to those
#so, to eliminate these observations, use anti-join
#removes observations from df which are present in tanksdays...
df_mod = tanksdays_changingstriders %>% filter(n > 1) %>%
select(-n) %>% #this line removes the n column, which we no longer need
anti_join(df, ., by = c("date", "tank"))
(nrow(df) - nrow(df_mod))/nrow(df)
#df_mod contains observations where group membership does not change on a single day
#so now, let's calculate the unique groups labels, which is the unique combination
#of uniq_id and tank id
df_mod$groupID = paste0("group", df_mod$tank, " ", df_mod$uniq_ids)
#those groups
#to do this, I will group by our new "groupID" variable, and then sort the data
#within that grouping variable by "date", 'time', and 'id' so that when we add
#a new trial column according to date, we can be sure that the earliest date corresponds
#to the earliest trial
#this probably isn't necessary, assuming the data are already correctly sorted, but on the
#off chance that for some data the values are not entered chronologically, this code
#will prevent that from being an issue
#note that in the arrange code, the .by_group argument ensures that the data are arranged
#within their grouping category (rather than as a whole, regardless of grouping)
df_mod = df_mod %>% group_by(groupID) %>% arrange(date, time, id, .by_group = T) %>%
mutate(trial = as.integer(as.factor(date))) %>% ungroup()
#we have found that sex and treatment are problematic because there are multiple
#entries of sex and treatment for some groupID-trial-id combinations
test = df_mod %>% group_by(groupID, trial, id) %>%
summarize( n_treatment = length(unique(Treatment)),
n_sex = length(unique(sex))) %>% ungroup()
save(df_mod, file = "./df_mod.rdata")
#fix issues with tanks who were assigned large treatment even though they are small
df_mod$Treatment <- ifelse(df_mod$groupID == "groupT20 144_157-G_160-R_161-B_39_97", small, df_mod$Treatment)
#fix issues with tanks who were assigned large treatment even though they are small
df_mod$Treatment <- ifelse(df_mod$groupID == "groupT20 144_157-G_160-R_161-B_39_97", "small", df_mod$Treatment)
load(file = "./df_mod.rdata")
load(file = "./df_mod.rdata")
#fix issues with tanks who were assigned large treatment even though they are small
df_mod$Treatment <- ifelse(df_mod$groupID == "groupT20 144_157-G_160-R_161-B_39_97", "small")
#fix issues with tanks who were assigned large treatment even though they are small
df_mod$Treatment <- ifelse(df_mod$groupID == "groupT20 144_157-G_160-R_161-B_39_97", "small", df_mod$Treatment)
load(file = "./df_mod.rdata")
#fix issues with tanks who were assigned large treatment even though they are small
df_mod$Treatment <- ifelse(df_mod$groupID == "groupT20 144_157-G_160-R_161-B_39_97", "small", df_mod$Treatment)
load(file = "./df_mod.rdata")
load(file = "./df_mod.rdata")
#fix issues with tanks who were assigned large treatment even though they are small
df_mod$Treatment <- ifelse(df_mod$groupID == "groupT20 144_157-G_160-R_161-B_39_97", "small", df_mod$Treatment)
load(file = "./df_mod.rdata")
getwd()
load(file = "./df_mod.rdata")
load(file = "./df_mod.rdata")
#fix issues with tanks who were assigned large treatment even though they are small
df_mod$Treatment <- ifelse(df_mod$groupID == "groupT20 144_157-G_160-R_161-B_39_97", "small", df_mod$Treatment)
load(file = "./df_mod.rdata")
class(df_mod$Treatment)
#fix issues with tanks who were assigned large treatment even though they are small
df_mod$Treatment <- as.character(df_mod$Treatment)
df_mod$Treatment <- ifelse(df_mod$groupID == "groupT20 144_157-G_160-R_161-B_39_97", "small", df_mod$Treatment)
class(df_mod$sex)
#fix sex for individual 145-Y who was assigned male for one entry
df_mod$sex <- as.character(df_mod$sex)
df_mod$sex <- ifelse(df_mod$id == "145-Y", "F", df_mod$sex)
#we have found that sex and treatment are problematic because there are multiple
#entries of sex and treatment for some groupID-trial-id combinations
test = df_mod %>% group_by(groupID, trial, id) %>%
summarize( n_treatment = length(unique(Treatment)),
n_sex = length(unique(sex))) %>% ungroup()
View(test)
#and so now we want to calculate the proportion of time active and mating, within a day,
#for each male, for each of its observed trials, for each of its observed groups
#but remember that trial is the same thing as day
df_mod = df_mod %>% group_by(groupID, trial, id) %>%
summarize(prop_active = sum(activity, na.rm = T)/sum(!is.na(activity)),
prop_mating = sum(mating, na.rm = T)/sum(!is.na(mating)),
sex = unique(sex),
date = unique(date),
Treatment = unique(Treatment),
tank = unique(tank)) %>% ungroup()
save(df_mod, file = "./df_mod.rdata")
load(file = "./df_mod.rdata")
df = data
df = df %>% group_by(date, tank, time) %>%
mutate(uniq_ids = paste0(sort(unique(id)), collapse = "_")) %>% ungroup()
tanksdays_changingstriders = df %>% group_by(date, tank) %>% summarize(n = length(unique(uniq_ids))) %>% ungroup()
tanksdays_changingstriders %>% filter(n > 1) #filter code filters the dataframe to those
#so, to eliminate these observations, use anti-join
#removes observations from df which are present in tanksdays...
df_mod = tanksdays_changingstriders %>% filter(n > 1) %>%
select(-n) %>% #this line removes the n column, which we no longer need
anti_join(df, ., by = c("date", "tank"))
(nrow(df) - nrow(df_mod))/nrow(df)
#df_mod contains observations where group membership does not change on a single day
#so now, let's calculate the unique groups labels, which is the unique combination
#of uniq_id and tank id
df_mod$groupID = paste0("group", df_mod$tank, " ", df_mod$uniq_ids)
#those groups
#to do this, I will group by our new "groupID" variable, and then sort the data
#within that grouping variable by "date", 'time', and 'id' so that when we add
#a new trial column according to date, we can be sure that the earliest date corresponds
#to the earliest trial
#this probably isn't necessary, assuming the data are already correctly sorted, but on the
#off chance that for some data the values are not entered chronologically, this code
#will prevent that from being an issue
#note that in the arrange code, the .by_group argument ensures that the data are arranged
#within their grouping category (rather than as a whole, regardless of grouping)
df_mod = df_mod %>% group_by(groupID) %>% arrange(date, time, id, .by_group = T) %>%
mutate(trial = as.integer(as.factor(date))) %>% ungroup()
#we have found that sex and treatment are problematic because there are multiple
#entries of sex and treatment for some groupID-trial-id combinations
test = df_mod %>% group_by(groupID, trial, id) %>%
summarize( n_treatment = length(unique(Treatment)),
n_sex = length(unique(sex))) %>% ungroup()
#fix issues with tanks who were assigned large treatment even though they are small
df_mod$Treatment <- as.character(df_mod$Treatment)
df_mod$Treatment <- ifelse(df_mod$groupID == "groupT20 144_157-G_160-R_161-B_39_97", "small", df_mod$Treatment)
#fix sex for individual 145-Y who was assigned male for one entry
df_mod$sex <- as.character(df_mod$sex)
df_mod$sex <- ifelse(df_mod$id == "145-Y", "F", df_mod$sex)
#and so now we want to calculate the proportion of time active and mating, within a day,
#for each male, for each of its observed trials, for each of its observed groups
#but remember that trial is the same thing as day
bloop = df_mod %>% group_by(groupID, trial, id) %>%
summarize(prop_active = sum(activity, na.rm = T)/sum(!is.na(activity)),
prop_mating = sum(mating, na.rm = T)/sum(!is.na(mating)))
View(bloop)
#and so now we want to calculate the proportion of time active and mating, within a day,
#for each male, for each of its observed trials, for each of its observed groups
#but remember that trial is the same thing as day
bloop = df_mod %>% group_by(groupID, trial, id) %>%
summarize(prop_active = sum(activity, na.rm = T)/sum(!is.na(activity)),
prop_mating = sum(mating, na.rm = T)/sum(!is.na(mating)),
sex = unique(sex),
date = unique(date),
Treatment = unique(Treatment),
tank = unique(tank))) %>% ungroup()
bloop = df_mod %>% group_by(groupID, trial, id) %>%
summarize(prop_active = sum(activity, na.rm = T)/sum(!is.na(activity)),
prop_mating = sum(mating, na.rm = T)/sum(!is.na(mating)),
sex = unique(sex),
date = unique(date),
Treatment = unique(Treatment),
tank = unique(tank)) %>% ungroup()
save(df_mod, file = "./df_mod.rdata")
load(file = "./df_mod.rdata")
#we have found that sex and treatment are problematic because there are multiple
#entries of sex and treatment for some groupID-trial-id combinations
test = df_mod %>% group_by(groupID, trial, id) %>%
summarize( n_treatment = length(unique(Treatment)),
n_sex = length(unique(sex))) %>% ungroup()
View(test)
View(df)
df = df %>% group_by(date, tank) %>%
mutate(uniq_ids = paste0(sort(unique(id)), collapse = "_")) %>% ungroup()
df = data
dfblu = df %>% group_by(date, tank) %>%
mutate(uniq_ids = paste0(sort(unique(id)), collapse = "_")) %>% ungroup()
View(dfblu)
unique(dfblu$uniq_ids)
length(unique(dfblu$uniq_ids))
dfblu = df %>% group_by(tank) %>%
mutate(uniq_ids = paste0(sort(unique(id)), collapse = "_")) %>% ungroup()
length(unique(dfblu$uniq_ids))
dfblu = df %>% group_by(date, tank, time) %>%
mutate(uniq_ids = paste0(sort(unique(id)), collapse = "_")) %>% ungroup()
length(unique(dfblu$uniq_ids))
dfblu = df %>% group_by(date, tank) %>%
mutate(uniq_ids = paste0(sort(unique(id)), collapse = "_")) %>% ungroup()
length(unique(df_mod$groupID))
dfblu$groups <- as.factor(dfblu$uniq_ids)
str(dfblu$groups)
tanksdays_changingstriders = df %>% group_by(date, tank) %>% summarize(n = length(unique(uniq_ids))) %>% ungroup()
tanksdays_changingstriders = dfblue %>% group_by(date, tank) %>% summarize(n = length(unique(uniq_ids))) %>% ungroup()
tanksdays_changingstriders = dfblu %>% group_by(date, tank) %>% summarize(n = length(unique(uniq_ids))) %>% ungroup()
tanksdays_changingstriders %>% filter(n > 1) #filter code filters the dataframe to those
View(tanksdays_changingstriders)
#so, to eliminate these observations, use anti-join
#removes observations from df which are present in tanksdays...
dfblu = tanksdays_changingstriders %>% filter(n > 1) %>%
select(-n) %>% #this line removes the n column, which we no longer need
anti_join(df, ., by = c("date", "tank"))
#df_mod contains observations where group membership does not change on a single day
#so now, let's calculate the unique groups labels, which is the unique combination
#of uniq_id and tank id
dfblue$groupID = paste0("group", df_mod$tank, " ", df_mod$uniq_ids)
#df_mod contains observations where group membership does not change on a single day
#so now, let's calculate the unique groups labels, which is the unique combination
#of uniq_id and tank id
dfblu$groupID = paste0("group", df_mod$tank, " ", df_mod$uniq_ids)
View(bloop)
df = df %>% group_by(date, tank) %>%
mutate(group_id = paste0(date, time)) %>% ungroup()
blap = df %>% group_by(date, tank) %>%
mutate(group_id = paste0(date, time)) %>% ungroup()
df = data
df = df %>% group_by(date, tank, time) %>%
mutate(uniq_ids = paste0(sort(unique(id)), collapse = "_")) %>% ungroup()
View(dfblu)
View(blap)
df = df %>% group_by(date, tank, time) %>%
mutate(uniq_ids = paste(sort(unique(id)), collapse = "_")) %>% ungroup()
df = df %>% group_by(date, tank, time) %>%
mutate(uniq_ids = paste0(sort(unique(id)), collapse = "_")) %>% ungroup()
blap = df %>% group_by(date, tank) %>%
mutate(group_id = paste(date, time)) %>% ungroup()
tanksdays_changingstriders = df %>% group_by(date, tank) %>% summarize(n = length(unique(uniq_ids))) %>% ungroup()
View(tanksdays_changingstriders)
View(bloop)
