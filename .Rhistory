df_mod$Treatment <- ifelse(df_mod$groupID == "groupT20 144_157-G_160-R_161-B_39_97", "small")
#fix issues with tanks who were assigned large treatment even though they are small
df_mod$Treatment <- ifelse(df_mod$groupID == "groupT20 144_157-G_160-R_161-B_39_97", "small", df_mod$Treatment)
load(file = "./df_mod.rdata")
#fix issues with tanks who were assigned large treatment even though they are small
df_mod$Treatment <- ifelse(df_mod$groupID == "groupT20 144_157-G_160-R_161-B_39_97", "small", df_mod$Treatment)
load(file = "./df_mod.rdata")
load(file = "./df_mod.rdata")
#fix issues with tanks who were assigned large treatment even though they are small
df_mod$Treatment <- ifelse(df_mod$groupID == "groupT20 144_157-G_160-R_161-B_39_97", "small", df_mod$Treatment)
load(file = "./df_mod.rdata")
getwd()
load(file = "./df_mod.rdata")
load(file = "./df_mod.rdata")
#fix issues with tanks who were assigned large treatment even though they are small
df_mod$Treatment <- ifelse(df_mod$groupID == "groupT20 144_157-G_160-R_161-B_39_97", "small", df_mod$Treatment)
load(file = "./df_mod.rdata")
class(df_mod$Treatment)
#fix issues with tanks who were assigned large treatment even though they are small
df_mod$Treatment <- as.character(df_mod$Treatment)
df_mod$Treatment <- ifelse(df_mod$groupID == "groupT20 144_157-G_160-R_161-B_39_97", "small", df_mod$Treatment)
class(df_mod$sex)
#fix sex for individual 145-Y who was assigned male for one entry
df_mod$sex <- as.character(df_mod$sex)
df_mod$sex <- ifelse(df_mod$id == "145-Y", "F", df_mod$sex)
#we have found that sex and treatment are problematic because there are multiple
#entries of sex and treatment for some groupID-trial-id combinations
test = df_mod %>% group_by(groupID, trial, id) %>%
summarize( n_treatment = length(unique(Treatment)),
n_sex = length(unique(sex))) %>% ungroup()
View(test)
#and so now we want to calculate the proportion of time active and mating, within a day,
#for each male, for each of its observed trials, for each of its observed groups
#but remember that trial is the same thing as day
df_mod = df_mod %>% group_by(groupID, trial, id) %>%
summarize(prop_active = sum(activity, na.rm = T)/sum(!is.na(activity)),
prop_mating = sum(mating, na.rm = T)/sum(!is.na(mating)),
sex = unique(sex),
date = unique(date),
Treatment = unique(Treatment),
tank = unique(tank)) %>% ungroup()
save(df_mod, file = "./df_mod.rdata")
load(file = "./df_mod.rdata")
df = data
df = df %>% group_by(date, tank, time) %>%
mutate(uniq_ids = paste0(sort(unique(id)), collapse = "_")) %>% ungroup()
tanksdays_changingstriders = df %>% group_by(date, tank) %>% summarize(n = length(unique(uniq_ids))) %>% ungroup()
tanksdays_changingstriders %>% filter(n > 1) #filter code filters the dataframe to those
#so, to eliminate these observations, use anti-join
#removes observations from df which are present in tanksdays...
df_mod = tanksdays_changingstriders %>% filter(n > 1) %>%
select(-n) %>% #this line removes the n column, which we no longer need
anti_join(df, ., by = c("date", "tank"))
(nrow(df) - nrow(df_mod))/nrow(df)
#df_mod contains observations where group membership does not change on a single day
#so now, let's calculate the unique groups labels, which is the unique combination
#of uniq_id and tank id
df_mod$groupID = paste0("group", df_mod$tank, " ", df_mod$uniq_ids)
#those groups
#to do this, I will group by our new "groupID" variable, and then sort the data
#within that grouping variable by "date", 'time', and 'id' so that when we add
#a new trial column according to date, we can be sure that the earliest date corresponds
#to the earliest trial
#this probably isn't necessary, assuming the data are already correctly sorted, but on the
#off chance that for some data the values are not entered chronologically, this code
#will prevent that from being an issue
#note that in the arrange code, the .by_group argument ensures that the data are arranged
#within their grouping category (rather than as a whole, regardless of grouping)
df_mod = df_mod %>% group_by(groupID) %>% arrange(date, time, id, .by_group = T) %>%
mutate(trial = as.integer(as.factor(date))) %>% ungroup()
#we have found that sex and treatment are problematic because there are multiple
#entries of sex and treatment for some groupID-trial-id combinations
test = df_mod %>% group_by(groupID, trial, id) %>%
summarize( n_treatment = length(unique(Treatment)),
n_sex = length(unique(sex))) %>% ungroup()
#fix issues with tanks who were assigned large treatment even though they are small
df_mod$Treatment <- as.character(df_mod$Treatment)
df_mod$Treatment <- ifelse(df_mod$groupID == "groupT20 144_157-G_160-R_161-B_39_97", "small", df_mod$Treatment)
#fix sex for individual 145-Y who was assigned male for one entry
df_mod$sex <- as.character(df_mod$sex)
df_mod$sex <- ifelse(df_mod$id == "145-Y", "F", df_mod$sex)
#and so now we want to calculate the proportion of time active and mating, within a day,
#for each male, for each of its observed trials, for each of its observed groups
#but remember that trial is the same thing as day
bloop = df_mod %>% group_by(groupID, trial, id) %>%
summarize(prop_active = sum(activity, na.rm = T)/sum(!is.na(activity)),
prop_mating = sum(mating, na.rm = T)/sum(!is.na(mating)))
View(bloop)
#and so now we want to calculate the proportion of time active and mating, within a day,
#for each male, for each of its observed trials, for each of its observed groups
#but remember that trial is the same thing as day
bloop = df_mod %>% group_by(groupID, trial, id) %>%
summarize(prop_active = sum(activity, na.rm = T)/sum(!is.na(activity)),
prop_mating = sum(mating, na.rm = T)/sum(!is.na(mating)),
sex = unique(sex),
date = unique(date),
Treatment = unique(Treatment),
tank = unique(tank))) %>% ungroup()
bloop = df_mod %>% group_by(groupID, trial, id) %>%
summarize(prop_active = sum(activity, na.rm = T)/sum(!is.na(activity)),
prop_mating = sum(mating, na.rm = T)/sum(!is.na(mating)),
sex = unique(sex),
date = unique(date),
Treatment = unique(Treatment),
tank = unique(tank)) %>% ungroup()
save(df_mod, file = "./df_mod.rdata")
load(file = "./df_mod.rdata")
#we have found that sex and treatment are problematic because there are multiple
#entries of sex and treatment for some groupID-trial-id combinations
test = df_mod %>% group_by(groupID, trial, id) %>%
summarize( n_treatment = length(unique(Treatment)),
n_sex = length(unique(sex))) %>% ungroup()
View(test)
View(df)
df = df %>% group_by(date, tank) %>%
mutate(uniq_ids = paste0(sort(unique(id)), collapse = "_")) %>% ungroup()
df = data
dfblu = df %>% group_by(date, tank) %>%
mutate(uniq_ids = paste0(sort(unique(id)), collapse = "_")) %>% ungroup()
View(dfblu)
unique(dfblu$uniq_ids)
length(unique(dfblu$uniq_ids))
dfblu = df %>% group_by(tank) %>%
mutate(uniq_ids = paste0(sort(unique(id)), collapse = "_")) %>% ungroup()
length(unique(dfblu$uniq_ids))
dfblu = df %>% group_by(date, tank, time) %>%
mutate(uniq_ids = paste0(sort(unique(id)), collapse = "_")) %>% ungroup()
length(unique(dfblu$uniq_ids))
dfblu = df %>% group_by(date, tank) %>%
mutate(uniq_ids = paste0(sort(unique(id)), collapse = "_")) %>% ungroup()
length(unique(df_mod$groupID))
dfblu$groups <- as.factor(dfblu$uniq_ids)
str(dfblu$groups)
tanksdays_changingstriders = df %>% group_by(date, tank) %>% summarize(n = length(unique(uniq_ids))) %>% ungroup()
tanksdays_changingstriders = dfblue %>% group_by(date, tank) %>% summarize(n = length(unique(uniq_ids))) %>% ungroup()
tanksdays_changingstriders = dfblu %>% group_by(date, tank) %>% summarize(n = length(unique(uniq_ids))) %>% ungroup()
tanksdays_changingstriders %>% filter(n > 1) #filter code filters the dataframe to those
View(tanksdays_changingstriders)
#so, to eliminate these observations, use anti-join
#removes observations from df which are present in tanksdays...
dfblu = tanksdays_changingstriders %>% filter(n > 1) %>%
select(-n) %>% #this line removes the n column, which we no longer need
anti_join(df, ., by = c("date", "tank"))
#df_mod contains observations where group membership does not change on a single day
#so now, let's calculate the unique groups labels, which is the unique combination
#of uniq_id and tank id
dfblue$groupID = paste0("group", df_mod$tank, " ", df_mod$uniq_ids)
#df_mod contains observations where group membership does not change on a single day
#so now, let's calculate the unique groups labels, which is the unique combination
#of uniq_id and tank id
dfblu$groupID = paste0("group", df_mod$tank, " ", df_mod$uniq_ids)
View(bloop)
df = df %>% group_by(date, tank) %>%
mutate(group_id = paste0(date, time)) %>% ungroup()
blap = df %>% group_by(date, tank) %>%
mutate(group_id = paste0(date, time)) %>% ungroup()
df = data
df = df %>% group_by(date, tank, time) %>%
mutate(uniq_ids = paste0(sort(unique(id)), collapse = "_")) %>% ungroup()
View(dfblu)
View(blap)
df = df %>% group_by(date, tank, time) %>%
mutate(uniq_ids = paste(sort(unique(id)), collapse = "_")) %>% ungroup()
df = df %>% group_by(date, tank, time) %>%
mutate(uniq_ids = paste0(sort(unique(id)), collapse = "_")) %>% ungroup()
blap = df %>% group_by(date, tank) %>%
mutate(group_id = paste(date, time)) %>% ungroup()
tanksdays_changingstriders = df %>% group_by(date, tank) %>% summarize(n = length(unique(uniq_ids))) %>% ungroup()
View(tanksdays_changingstriders)
View(bloop)
df = data
df = df %>% group_by(date, tank, time) %>%
mutate(uniq_ids = paste0(sort(unique(id)), collapse = "_")) %>% ungroup()
tanksdays_changingstriders = df %>% group_by(date, tank) %>% summarize(n = length(unique(uniq_ids))) %>% ungroup()
library(dplyr)
View(utm_pups)
data <- read.csv("data.csv")
df = data
tanksdays_changingstriders = df %>% group_by(date, tank) %>% summarize(n = length(unique(uniq_ids))) %>% ungroup()
df = df %>% group_by(date, tank, time) %>%
mutate(uniq_ids = paste0(sort(unique(id)), collapse = "_")) %>% ungroup()
tanksdays_changingstriders = df %>% group_by(date, tank) %>% summarize(n = length(unique(uniq_ids))) %>% ungroup()
View(tanksdays_changingstriders)
View(tanksdays_changingstriders)
View(tanksdays_changingstriders)
View(tanksdays_changingstriders)
#df_mod contains observations where group membership does not change on a single day
#so now, let's calculate the unique groups labels, which is the unique combination
#of uniq_id and tank id
df_mod$groupID = paste0("group", df_mod$tank, " ", df_mod$uniq_ids)
#so, to eliminate these observations, use anti-join
#removes observations from df which are present in tanksdays...
df_mod = tanksdays_changingstriders %>% filter(n > 1) %>%
select(-n) %>% #this line removes the n column, which we no longer need
anti_join(df, ., by = c("date", "tank"))
#df_mod contains observations where group membership does not change on a single day
#so now, let's calculate the unique groups labels, which is the unique combination
#of uniq_id and tank id
df_mod$groupID = paste0("group", df_mod$tank, " ", df_mod$uniq_ids)
View(df_mod)
?arrange
#those groups
#to do this, I will group by our new "groupID" variable, and then sort the data
#within that grouping variable by "date", 'time', and 'id' so that when we add
#a new trial column according to date, we can be sure that the earliest date corresponds
#to the earliest trial
#this probably isn't necessary, assuming the data are already correctly sorted, but on the
#off chance that for some data the values are not entered chronologically, this code
#will prevent that from being an issue
#note that in the arrange code, the .by_group argument ensures that the data are arranged
#within their grouping category (rather than as a whole, regardless of grouping)
df_mod = df_mod %>% group_by(groupID) %>% arrange(date, time, id, .by_group = T) %>%
mutate(trial = as.integer(as.factor(date))) %>% ungroup()
#we have found that sex and treatment are problematic because there are multiple
#entries of sex and treatment for some groupID-trial-id combinations
test = df_mod %>% group_by(groupID, trial, id) %>%
summarize( n_treatment = length(unique(Treatment)),
n_sex = length(unique(sex))) %>% ungroup()
View(test)
bloop = df_mod %>% group_by(groupID, trial, id) %>%
summarize(prop_active = sum(activity, na.rm = T)/sum(!is.na(activity)),
prop_mating = sum(mating, na.rm = T)/sum(!is.na(mating)),
sex = unique(sex),
date = unique(date),
Treatment = unique(Treatment),
tank = unique(tank)) %>% ungroup()
#and so now we want to calculate the proportion of time active and mating, within a day,
#for each male, for each of its observed trials, for each of its observed groups
#but remember that trial is the same thing as day
bloop = df_mod %>% group_by(groupID, trial, id) %>%
summarize(prop_active = sum(activity, na.rm = T)/sum(!is.na(activity)),
prop_mating = sum(mating, na.rm = T)/sum(!is.na(mating)),
sex = unique(sex),
date = unique(date),
Treatment = unique(Treatment),
tank = unique(tank)) %>% ungroup()
View(df_mod)
unique(df_mod$mating)
data$mating <- ifelse(data$mating == "N" | data$mating == "C" | data$mating == "DEAD" |data$mating == "Dead?" |data$mating == "?" |data$mating == "<NA>" | data$mating == "OVI" |data$mating == "v" |data$mating == "ES" |data$mating == "O" |data$mating == "V", "0", "1")
View(data)
unique(data$Treatment)
unique(data$mating)
unique(data$activity)
class(data$activity)
unique(data$mating)
###change activity to binary
data$activity <- felse(data$activity == "1", "1", "0")
###change activity to binary
data$activity <- ifelse(data$activity == "1", "1", "0")
unique(data$activity)
df = data
df = df %>% group_by(date, tank, time) %>%
mutate(uniq_ids = paste0(sort(unique(id)), collapse = "_")) %>% ungroup()
tanksdays_changingstriders = df %>% group_by(date, tank) %>% summarize(n = length(unique(uniq_ids))) %>% ungroup()
tanksdays_changingstriders %>% filter(n > 1) #filter code filters the dataframe to those
#so, to eliminate these observations, use anti-join
#removes observations from df which are present in tanksdays...
df_mod = tanksdays_changingstriders %>% filter(n > 1) %>%
select(-n) %>% #this line removes the n column, which we no longer need
anti_join(df, ., by = c("date", "tank"))
(nrow(df) - nrow(df_mod))/nrow(df)
#df_mod contains observations where group membership does not change on a single day
#so now, let's calculate the unique groups labels, which is the unique combination
#of uniq_id and tank id
df_mod$groupID = paste0("group", df_mod$tank, " ", df_mod$uniq_ids)
#those groups
#to do this, I will group by our new "groupID" variable, and then sort the data
#within that grouping variable by "date", 'time', and 'id' so that when we add
#a new trial column according to date, we can be sure that the earliest date corresponds
#to the earliest trial
#this probably isn't necessary, assuming the data are already correctly sorted, but on the
#off chance that for some data the values are not entered chronologically, this code
#will prevent that from being an issue
#note that in the arrange code, the .by_group argument ensures that the data are arranged
#within their grouping category (rather than as a whole, regardless of grouping)
df_mod = df_mod %>% group_by(groupID) %>% arrange(date, time, id, .by_group = T) %>%
mutate(trial = as.integer(as.factor(date))) %>% ungroup()
#we have found that sex and treatment are problematic because there are multiple
#entries of sex and treatment for some groupID-trial-id combinations
test = df_mod %>% group_by(groupID, trial, id) %>%
summarize( n_treatment = length(unique(Treatment)),
n_sex = length(unique(sex))) %>% ungroup()
#fix issues with tanks who were assigned large treatment even though they are small
df_mod$Treatment <- as.character(df_mod$Treatment)
df_mod$Treatment <- ifelse(df_mod$groupID == "groupT20 144_157-G_160-R_161-B_39_97", "small", df_mod$Treatment)
#fix sex for individual 145-Y who was assigned male for one entry
df_mod$sex <- as.character(df_mod$sex)
df_mod$sex <- ifelse(df_mod$id == "145-Y", "F", df_mod$sex)
#and so now we want to calculate the proportion of time active and mating, within a day,
#for each male, for each of its observed trials, for each of its observed groups
#but remember that trial is the same thing as day
df_mod$activity <- as.numeric(df_mod$activity)
df_mod$mating <- as.numeric(df_mod$mating)
bloop = df_mod %>% group_by(groupID, trial, id) %>%
summarize(prop_active = sum(activity, na.rm = T)/sum(!is.na(activity)),
prop_mating = sum(mating, na.rm = T)/sum(!is.na(mating)),
sex = unique(sex),
date = unique(date),
Treatment = unique(Treatment),
tank = unique(tank)) %>% ungroup()
View(bloop)
unique(data$behavior)
###change behavior to binary
data$behavior <- ifelse(data$activity == "W" | data$activity == "WC" | data$activity == "WES" | data$activity == "WF" , "1", "0")
unique(data$behavior)
data <- read.csv("data.csv")
###change mating to binary
data$mating <- ifelse(data$mating == "N" | data$mating == "C" | data$mating == "DEAD" |data$mating == "Dead?" |data$mating == "?" |data$mating == "<NA>" | data$mating == "OVI" |data$mating == "v" |data$mating == "ES" |data$mating == "O" |data$mating == "V", "0", "1")
###change activity to binary
data$activity <- ifelse(data$activity == "1", "1", "0")
###change behavior to binary
data$behavior <- ifelse(data$behavior == "W" | data$behavior == "WC" | data$behavior == "WES" | data$behavior == "WF" , "1", "0")
unique(data$behavior)
df = data
df = df %>% group_by(date, tank, time) %>%
mutate(uniq_ids = paste0(sort(unique(id)), collapse = "_")) %>% ungroup()
tanksdays_changingstriders = df %>% group_by(date, tank) %>% summarize(n = length(unique(uniq_ids))) %>% ungroup()
tanksdays_changingstriders %>% filter(n > 1) #filter code filters the dataframe to those
#so, to eliminate these observations, use anti-join
#removes observations from df which are present in tanksdays...
df_mod = tanksdays_changingstriders %>% filter(n > 1) %>%
select(-n) %>% #this line removes the n column, which we no longer need
anti_join(df, ., by = c("date", "tank"))
(nrow(df) - nrow(df_mod))/nrow(df)
#df_mod contains observations where group membership does not change on a single day
#so now, let's calculate the unique groups labels, which is the unique combination
#of uniq_id and tank id
df_mod$groupID = paste0("group", df_mod$tank, " ", df_mod$uniq_ids)
#those groups
#to do this, I will group by our new "groupID" variable, and then sort the data
#within that grouping variable by "date", 'time', and 'id' so that when we add
#a new trial column according to date, we can be sure that the earliest date corresponds
#to the earliest trial
#this probably isn't necessary, assuming the data are already correctly sorted, but on the
#off chance that for some data the values are not entered chronologically, this code
#will prevent that from being an issue
#note that in the arrange code, the .by_group argument ensures that the data are arranged
#within their grouping category (rather than as a whole, regardless of grouping)
df_mod = df_mod %>% group_by(groupID) %>% arrange(date, time, id, .by_group = T) %>%
mutate(trial = as.integer(as.factor(date))) %>% ungroup()
#we have found that sex and treatment are problematic because there are multiple
#entries of sex and treatment for some groupID-trial-id combinations
test = df_mod %>% group_by(groupID, trial, id) %>%
summarize( n_treatment = length(unique(Treatment)),
n_sex = length(unique(sex))) %>% ungroup()
#fix issues with tanks who were assigned large treatment even though they are small
df_mod$Treatment <- as.character(df_mod$Treatment)
df_mod$Treatment <- ifelse(df_mod$groupID == "groupT20 144_157-G_160-R_161-B_39_97", "small", df_mod$Treatment)
#fix sex for individual 145-Y who was assigned male for one entry
df_mod$sex <- as.character(df_mod$sex)
df_mod$sex <- ifelse(df_mod$id == "145-Y", "F", df_mod$sex)
#and so now we want to calculate the proportion of time active and mating, within a day,
#for each male, for each of its observed trials, for each of its observed groups
#but remember that trial is the same thing as day
df_mod$activity <- as.numeric(df_mod$activity)
df_mod$mating <- as.numeric(df_mod$mating)
#and so now we want to calculate the proportion of time active and mating, within a day,
#for each male, for each of its observed trials, for each of its observed groups
#but remember that trial is the same thing as day
df_mod$behavior <- as.numeric(df_mod$behavior)
bloop = df_mod %>% group_by(groupID, trial, id) %>%
summarize(prop_active = sum(behavior, na.rm = T)/sum(!is.na(behavior)),
prop_mating = sum(mating, na.rm = T)/sum(!is.na(mating)),
sex = unique(sex),
date = unique(date),
Treatment = unique(Treatment),
tank = unique(tank)) %>% ungroup()
View(bloop)
bloop = df_mod %>% group_by(groupID, trial, id) %>%
summarize(prop_behavior = sum(behavior, na.rm = T)/sum(!is.na(behavior)),
prop_mating = sum(mating, na.rm = T)/sum(!is.na(mating)),
sex = unique(sex),
date = unique(date),
Treatment = unique(Treatment),
tank = unique(tank)) %>% ungroup()
View(bloop)
bloop = df_mod %>% group_by(date, id) %>%
summarize(prop_behavior = sum(behavior, na.rm = T)/sum(!is.na(behavior)),
prop_mating = sum(mating, na.rm = T)/sum(!is.na(mating)),
sex = unique(sex),
date = unique(date),
Treatment = unique(Treatment),
tank = unique(tank)) %>% ungroup()
bloop = df_mod %>% group_by(date, id) %>%
summarize(prop_behavior = sum(behavior, na.rm = T)/sum(!is.na(behavior)),
prop_mating = sum(mating, na.rm = T)/sum(!is.na(mating)),
sex = unique(sex),
Treatment = unique(Treatment),
tank = unique(tank)) %>% ungroup()
#we have found that sex and treatment are problematic because there are multiple
#entries of sex and treatment for some groupID-trial-id combinations
test = df_mod %>% group_by(groupID, trial, id) %>%
summarize( n_treatment = length(unique(Treatment)),
n_sex = length(unique(sex))) %>% ungroup()
View(test)
#we have found that sex and treatment are problematic because there are multiple
#entries of sex and treatment for some groupID-trial-id combinations
test = df_mod %>% group_by(groupID, trial, id) %>%
summarize( n_treatment = length(unique(Treatment)),
n_sex = length(unique(sex))) %>% ungroup()
#fix issues with tanks who were assigned large treatment even though they are small
df_mod$Treatment <- as.character(df_mod$Treatment)
df_mod$Treatment <- ifelse(df_mod$groupID == "groupT20 144_157-G_160-R_161-B_39_97", "small", df_mod$Treatment)
#fix sex for individual 145-Y who was assigned male for one entry
df_mod$sex <- as.character(df_mod$sex)
df_mod$sex <- ifelse(df_mod$id == "145-Y", "F", df_mod$sex)
bloop = df_mod %>% group_by(date, id) %>%
summarize(prop_behavior = sum(behavior, na.rm = T)/sum(!is.na(behavior)),
prop_mating = sum(mating, na.rm = T)/sum(!is.na(mating)),
sex = unique(sex),
Treatment = unique(Treatment),
tank = unique(tank)) %>% ungroup()
test = df_mod %>% group_by(date, id) %>%
summarize( n_treatment = length(unique(Treatment)),
n_sex = length(unique(sex))) %>% ungroup()
View(test)
View(df_mod)
View(test)
View(test)
###exclude strider 98-Y because they they have a lot of contradicting data
test = df_mod %>% group_by(date, id) %>%
summarize( n_treatment = length(unique(Treatment)),
n_sex = length(unique(sex))) %>% ungroup()
View(test)
df_mod = test %>% filter(id == "98-Y") %>%
select(-n) %>% #this line removes the n column, which we no longer need
anti_join(df, ., by = c("date", "tank"))
df_mod = test %>% filter(id == "98-Y") %>%
select(-n_sex, -n_treatment) %>% #this line removes the n column, which we no longer need
anti_join(df, ., by = c("date", "tank"))
df_mod = test %>% filter(id == "98-Y") %>%
select(-n_sex, -n_treatment) %>% #this line removes the n column, which we no longer need
anti_join(df_mod, ., by = c("date", "tank"))
df_mod = test %>% filter(id == "98-Y") %>%
select(-n_sex, -n_treatment) %>% #this line removes the n column, which we no longer need
anti_join(df_mod, ., by = c("date", "id"))
bloop = df_mod %>% group_by(date, id) %>%
summarize(prop_behavior = sum(behavior, na.rm = T)/sum(!is.na(behavior)),
prop_mating = sum(mating, na.rm = T)/sum(!is.na(mating)),
sex = unique(sex),
Treatment = unique(Treatment),
tank = unique(tank)) %>% ungroup()
###exclude strider 98-Y because they they have a lot of contradicting data
test = df_mod %>% group_by(date, id) %>%
summarize( n_treatment = length(unique(Treatment)),
n_sex = length(unique(sex))) %>% ungroup()
View(test)
View(test)
View(df_mod %>% filter(date == "20130420" & id == "13"))
View(df_mod %>% filter(date == "20130420" & id == "13"))
View(df_mod %>% filter(date == "20130420" & id == "13"))
###exclude striders who have multiple entries
test = df_mod %>% group_by(date, id) %>%
summarize( n_treatment = length(unique(Treatment)),
n_sex = length(unique(sex))) %>% ungroup()
View(test)
###exclude striders who have multiple entries
test = df_mod %>% group_by(date, id) %>%
summarize( n_treatment = length(unique(Treatment)),
n_sex = length(unique(sex))) %>% ungroup()
View(test)
df_mod = test %>% filter(n_treatment > 1) %>%
select(-n_sex, -n_treatment) %>% #this line removes the n column, which we no longer need
anti_join(df_mod, ., by = c("date", "id"))
bloop = df_mod %>% group_by(date, id) %>%
summarize(prop_behavior = sum(behavior, na.rm = T)/sum(!is.na(behavior)),
prop_mating = sum(mating, na.rm = T)/sum(!is.na(mating)),
sex = unique(sex),
Treatment = unique(Treatment),
tank = unique(tank)) %>% ungroup()
###exclude striders who have multiple entries
test = df_mod %>% group_by(date, id) %>%
summarize( n_treatment = length(unique(Treatment)),
n_sex = length(unique(sex)), n_tank = length(unique(tank))) %>% ungroup()
View(test)
df_mod = test %>% filter(n_tank > 1) %>%
select(-n_sex, -n_treatment, -n_tank) %>% #this line removes the n column, which we no longer need
anti_join(df_mod, ., by = c("date", "id"))
bloop = df_mod %>% group_by(date, id) %>%
summarize(prop_behavior = sum(behavior, na.rm = T)/sum(!is.na(behavior)),
prop_mating = sum(mating, na.rm = T)/sum(!is.na(mating)),
sex = unique(sex),
Treatment = unique(Treatment),
tank = unique(tank)) %>% ungroup()
View(bloop)
unique(df_mod$tank)
rm(list = ls())
library(lme4)
library(MCMCglmm)
library(tidyverse)
library(broom)
library(nadiv)
df_syndrome <- read_csv("syndrome.csv")
###first assign an uninformative prior; later you should check your model results
prior_E_B_1px = list(R = list(V = diag(2), nu = 0.002),
G = list(G1 = list(V = diag(2), nu = 2, alpha.mu = rep(0,2),
alpha.V = diag(25^2,2,2))))
####set up model with bivariate response variable being boldness and exploration bound together using cbind
#scale response variables as well (centered around the mean and standarized to units of 1 phenotypic standard deviation)
mcmc_E_B_us <- MCMCglmm(cbind(scale(exploration), scale(boldness)) ~ trait-1 + trait:scale(assay_rep, scale = FALSE) +
trait:scale(body_size), #we use the trait keyword to specify that this is a multivariate model, trait-1 tells the model to give us a distinct intercept for each trait; we interact trait with the fixed effects so that we get estimates for the effect of these variables on each of our behaviors
random =~ us(trait):ID, #tells the model to fit an unstructured covariance matrix for the grouping variable ID, essentially we are calculating the variance in exploration due differences among individuals, the variance in boldness due to differences among individuals and the covariances between these variances
rcov =~ us(trait):units, #residual variance = within individual variation, because we have repeated measures for both traits at the individual level we also set aan unstructured covariance matrix; finds the residual variance for each trait and allows these variances to covary (???????)
family = c("gaussian","gaussian"),
prior = prior_E_B_1px, #include model priors
nitt=420000, #total number of iterations
burnin=20000, #number of iterations to discard as the model starts
thin=100, #number of iterations to discard inbetween successive stored samples, helps to reduce autocorrelation in sampling
verbose = TRUE,
data = as.data.frame(df_syndrome))
plot(mcmc_E_B_us$VCV)
summary(mcmc_E_B_us)
